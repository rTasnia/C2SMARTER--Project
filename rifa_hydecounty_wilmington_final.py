# -*- coding: utf-8 -*-
"""Rifa- hydecounty/wilmington final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1adm5oYQR_3Mg3b049xB54ybCsE86UGMi

# Rifa- hydecounty/wilmington
"""

!apt-get install -y python3-gdal
!pip install rasterio
!pip install osmnx
!pip install mapclassify folium matplotlib

# !pip install osmnx
# !pip install gdal
# !pip install rasterio

import osmnx as ox
from osgeo import gdal
import networkx as nx
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from shapely.geometry import LineString
from rasterio.mask import mask
import rasterio
# import contextily as ctx
# !pip install

# !pip install osmnx # install the osmnx library
import osmnx as ox # import the library and alias it as 'ox' for easier use
place_name = "Wilmington, North Carolina, USA"
G = ox.graph_from_place(place_name, network_type='drive')
ox.plot_graph(G)

san_drive = ox.speed.add_edge_speeds(G)
san_drive = ox.speed.add_edge_travel_times(G)

"""Re-imported the modules and apply elevation data:"""

#This code now works
san_drive = ox.elevation.add_node_elevations_raster(san_drive, 'USGS_13_n35w078_20151130.tif', cpus=1)
san_drive = ox.add_edge_grades(san_drive, add_absolute=True)

san_drive_node, san_drive_edge = ox.graph_to_gdfs(san_drive)

san_drive_node

san_drive_edge

import geopandas as gpd
import pandas as pd
import matplotlib.pyplot as plt
from shapely.geometry import Point

san_drive_node['elevation'].unique()

import matplotlib.pyplot as plt

# Ensure there are no NaN or invalid coordinates in the dataset
san_drive_node = san_drive_node.dropna(subset=['x', 'y'])

# Define the elevation thresholds for classification
flooded_threshold = 5  # Nodes at or below sea level
prone_threshold = 12  # Nodes between 0 and 10 meters are prone to flooding

# Classify nodes based on elevation
def classify_node_by_elevation(elevation):
    if np.isnan(elevation):
        return 'unknown'  # Handle NaN values
    elif elevation <= flooded_threshold:
        return 'flooded'
    elif flooded_threshold < elevation <= prone_threshold:
        return 'prone'
    else:
        return 'safe'

# Apply classification to the nodes
san_drive_node['flood_status'] = san_drive_node['elevation'].apply(classify_node_by_elevation)

# Assign colors to the nodes based on classification
node_color_map = {
    'flooded': 'blue',
    'prone': 'red',
    'safe': 'green',
    'unknown': 'gray'  # Optional color for nodes with unknown elevation
}
san_drive_node['color'] = san_drive_node['flood_status'].map(node_color_map)

# Plotting function
def plot_nodes_with_flood_status():
    fig, ax = plt.subplots(figsize=(12, 12))

    # Plot the road network without color (just as background)
    san_drive_edge.plot(ax=ax, color='black', linewidth=0.8, alpha=1)

    # Plot the nodes with colors based on their flood-prone status
    for status, color in node_color_map.items():
        subset = san_drive_node[san_drive_node['flood_status'] == status]
        if not subset.empty:
            subset.plot(ax=ax, color=color, markersize=20, alpha=0.8, label=status)

    # Set a fixed aspect ratio to avoid errors
    ax.set_aspect('equal', adjustable='box')

    # Add title, labels, and legend
    plt.title(" Road Network with Flood Risk Classification by Nodes")
    plt.xlabel("Longitude")
    plt.ylabel("Latitude")
    plt.legend(title="Flood Status")

    plt.show()

# Call the function to plot
plot_nodes_with_flood_status()

print(san_drive_node.columns)

flood_raster_path = "USGS_13_n35w078_20151130.tif"
flood_raster = rasterio.open(flood_raster_path)

# Inspect columns in san_drive_edge
print("san_drive_edge columns:", san_drive_edge.columns)

# Inspect columns in san_drive_node
print("san_drive_node columns:", san_drive_node.columns)
# Print the column names of san_drive_edge
print("Columns in san_drive_edge:", san_drive_edge.columns)

print(san_drive_node.columns)

import matplotlib.pyplot as plt
import rasterio
import numpy as np
from rasterio.plot import show
from matplotlib.colors import ListedColormap

# Ensure there are no NaN or invalid coordinates in the dataset
san_drive_node = san_drive_node.dropna(subset=['x', 'y'])

# Define the elevation thresholds for classification
flooded_threshold = 5  # Nodes at or below sea level
prone_threshold = 12  # Nodes between 5 and 12 meters are prone to flooding

# Classify nodes based on elevation
def classify_node_by_elevation(elevation):
    if np.isnan(elevation):
        return 'unknown'  # Handle NaN values
    elif elevation <= flooded_threshold:
        return 'flooded'
    elif flooded_threshold < elevation <= prone_threshold:
        return 'prone'
    else:
        return 'safe'

# Apply classification to the nodes
san_drive_node['flood_status'] = san_drive_node['elevation'].apply(classify_node_by_elevation)

# Assign colors to the nodes based on classification
node_color_map = {
    'flooded': 'blue',
    'prone': 'green',
    'safe': 'brown',
    'unknown': 'gray'  # Optional color for nodes with unknown elevation
}
san_drive_node['color'] = san_drive_node['flood_status'].map(node_color_map)

# Function to classify the raster data based on the same elevation thresholds
def classify_raster_data(raster, flooded_threshold, prone_threshold):
    classified = np.zeros_like(raster)
    classified[np.isnan(raster)] = np.nan
    classified[raster <= flooded_threshold] = 1
    classified[(raster > flooded_threshold) & (raster <= prone_threshold)] = 2
    classified[raster > prone_threshold] = 3
    return classified

# Plotting function with TIFF background
def plot_nodes_with_tiff_background(tiff_file):
    with rasterio.open(tiff_file) as src:
        elevation_data = src.read(1)

        # Classify the raster data
        classified_raster = classify_raster_data(elevation_data, flooded_threshold, prone_threshold)

        # Create a custom colormap for the raster data
        cmap = ListedColormap(['blue', 'green', 'brown'])

        fig, ax = plt.subplots(figsize=(12, 12))

        # Plot the classified raster as the background
        show(classified_raster, ax=ax, cmap=cmap, transform=src.transform, alpha=0.6)

        # Plot the road network without color (just as background)
        san_drive_edge.plot(ax=ax, color='lightgray', linewidth=0.5, alpha=1)

        # Plot the nodes with colors based on their flood-prone status
        for status, color in node_color_map.items():
            subset = san_drive_node[san_drive_node['flood_status'] == status]
            if not subset.empty:
                subset.plot(ax=ax, color=color, markersize=20, alpha=0.8, label=status)

        # Set a fixed aspect ratio to avoid errors
        ax.set_aspect('equal', adjustable='box')

        # Add title, labels, and legend
        plt.title("Node Flood Status Classification with Elevation Background")
        plt.xlabel("Longitude")
        plt.ylabel("Latitude")
        plt.legend(title="Flood Status")

        plt.show()

# Call the function to plot with the TIFF background
tiff_file = 'USGS_13_n35w078_20151130.tif'
plot_nodes_with_tiff_background(tiff_file)

import folium
import rasterio
import geopandas as gpd
import numpy as np
from rasterio import features
from rasterio.plot import show
from rasterio.transform import from_origin
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import os

# Ensure there are no NaN or invalid coordinates in the dataset
san_drive_node = san_drive_node.dropna(subset=['x', 'y'])

# Define the elevation thresholds for classification
flooded_threshold = 5  # Nodes at or below sea level
prone_threshold = 12  # Nodes between 5 and 12 meters are prone to flooding

# Classify nodes based on elevation
def classify_node_by_elevation(elevation):
    if np.isnan(elevation):
        return 'unknown'  # Handle NaN values
    elif elevation <= flooded_threshold:
        return 'flooded'
    elif flooded_threshold < elevation <= prone_threshold:
        return 'prone'
    else:
        return 'safe'

# Apply classification to the nodes
san_drive_node['flood_status'] = san_drive_node['elevation'].apply(classify_node_by_elevation)

# Assign colors to the nodes based on classification
node_color_map = {
    'flooded': 'blue',
    'prone': 'green',
    'safe': 'brown',
    'unknown': 'gray'  # Optional color for nodes with unknown elevation
}
san_drive_node['color'] = san_drive_node['flood_status'].map(node_color_map)

# Function to classify the raster data based on the same elevation thresholds
def classify_raster_data(raster, flooded_threshold, prone_threshold):
    classified = np.zeros_like(raster)
    classified[np.isnan(raster)] = np.nan
    classified[raster <= flooded_threshold] = 1
    classified[(raster > flooded_threshold) & (raster <= prone_threshold)] = 2
    classified[raster > prone_threshold] = 3
    return classified

# Generate a temporary file to store the raster classification as an image for Folium
def generate_raster_image(tiff_file):
    with rasterio.open(tiff_file) as src:
        elevation_data = src.read(1)

        # Classify the raster data
        classified_raster = classify_raster_data(elevation_data, flooded_threshold, prone_threshold)

        # Create a custom colormap for the raster data
        cmap = ListedColormap(['blue', 'green', 'brown'])

        # Save classified raster as image
        fig, ax = plt.subplots(figsize=(12, 12))
        show(classified_raster, ax=ax, cmap=cmap, transform=src.transform, alpha=0.6)

        temp_image_path = 'classified_raster.png'
        fig.savefig(temp_image_path, bbox_inches='tight', pad_inches=0)
        plt.close(fig)

        return temp_image_path, src.transform

# Plotting function with interactive Folium map
def plot_nodes_with_folium(tiff_file):
    temp_image_path, transform = generate_raster_image(tiff_file)

    # Initialize the Folium map centered around the nodes
    m = folium.Map(location=[san_drive_node.geometry.y.mean(), san_drive_node.geometry.x.mean()], zoom_start=12)

    # Add the raster image overlay
    bounds = [[transform[5], transform[2]], [transform[5] + transform[4], transform[2] + transform[0]]]
    folium.raster_layers.ImageOverlay(temp_image_path, bounds=bounds, opacity=1).add_to(m)

    # Add road network as a layer
    folium.GeoJson(san_drive_edge).add_to(m)

    # Add nodes with their respective colors
    for _, row in san_drive_node.iterrows():
        folium.CircleMarker(
            location=[row.geometry.y, row.geometry.x],
            radius=5,
            color=row['color'],
            fill=True,
            fill_color=row['color'],
            fill_opacity=0.8,
            popup=row['flood_status']
        ).add_to(m)

    return m

# Call the function to plot with the interactive Folium map
tiff_file = 'USGS_13_n35w078_20151130.tif'
interactive_map = plot_nodes_with_folium(tiff_file)

# Save and display the map
interactive_map.save('interactive_flood_map.html')
interactive_map

def generate_raster_image(tiff_file):
    with rasterio.open(tiff_file) as src:
        # Reproject to EPSG:4326 (WGS84)
        dst_crs = 'EPSG:4326'
        transform, width, height = rasterio.warp.calculate_default_transform(
            src.crs, dst_crs, src.width, src.height, *src.bounds)

        kwargs = src.meta.copy()
        kwargs.update({
            'crs': dst_crs,
            'transform': transform,
            'width': width,
            'height': height
        })

        temp_reprojected_file = 'reprojected_raster.tif'

        with rasterio.open(temp_reprojected_file, 'w', **kwargs) as dst:
            for i in range(1, src.count + 1):
                rasterio.warp.reproject(
                    source=rasterio.band(src, i),
                    destination=rasterio.band(dst, i),
                    src_transform=src.transform,
                    src_crs=src.crs,
                    dst_transform=transform,
                    dst_crs=dst_crs,
                    resampling=rasterio.warp.Resampling.nearest
                )

        # Open reprojected raster and classify it
        with rasterio.open(temp_reprojected_file) as reprojected_src:
            elevation_data = reprojected_src.read(1)

            # Classify the raster data
            classified_raster = classify_raster_data(elevation_data, flooded_threshold, prone_threshold)

            # Create a custom colormap for the raster data
            cmap = ListedColormap(['blue', 'green', 'brown'])

            # Save classified raster as image
            fig, ax = plt.subplots(figsize=(12, 12))
            show(classified_raster, ax=ax, cmap=cmap, transform=reprojected_src.transform, alpha=0.6)

            temp_image_path = 'classified_raster.png'
            fig.savefig(temp_image_path, bbox_inches='tight', pad_inches=0)
            plt.close(fig)

        return temp_image_path, reprojected_src.bounds

def plot_nodes_with_folium(tiff_file):
    temp_image_path, bounds = generate_raster_image(tiff_file)

    # Initialize the Folium map centered around the nodes
    m = folium.Map(location=[san_drive_node.geometry.y.mean(), san_drive_node.geometry.x.mean()], zoom_start=12)

    # Set bounds as [[southwest_lat, southwest_lng], [northeast_lat, northeast_lng]]
    bounds = [[bounds.bottom, bounds.left], [bounds.top, bounds.right]]
    folium.raster_layers.ImageOverlay(temp_image_path, bounds=bounds, opacity=1).add_to(m)

    # Add road network as a layer
    folium.GeoJson(san_drive_edge).add_to(m)

    # Add nodes with their respective colors
    for _, row in san_drive_node.iterrows():
        folium.CircleMarker(
            location=[row.geometry.y, row.geometry.x],
            radius=5,
            color=row['color'],
            fill=True,
            fill_color=row['color'],
            fill_opacity=0.8,
            popup=row['flood_status']
        ).add_to(m)

    return m

# Call the function to plot with the interactive Folium map
tiff_file = 'USGS_13_n35w078_20151130.tif'
interactive_map = plot_nodes_with_folium(tiff_file)

# Save and display the map
interactive_map.save('interactive_flood_map.html')
interactive_map